
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned int uint;

typedef uint8_t   u8;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint64_t u64;

#define popcount64 __builtin_popcountll

// TODO:
#if 1
#define BE64 __builtin_bswap64
#else
#define BE64
#endif
#define BE8

static inline u64 swap64q (const u64 x, const uint q) {

    return (x >> q) | (x << (64 - q));
}

static inline u64 swap64 (const u64 x) {

    return swap64q(x, popcount64(x));
}

typedef u64 u64x8  __attribute__ ((vector_size( 8 * sizeof(u64)))); // 512
typedef u64 u64x4  __attribute__ ((vector_size( 4 * sizeof(u64)))); // 256
typedef u64 u64x2  __attribute__ ((vector_size( 2 * sizeof(u64)))); // 128

typedef u32 u32x16 __attribute__ ((vector_size(16 * sizeof(u32)))); // 512
typedef u32 u32x8  __attribute__ ((vector_size( 8 * sizeof(u32)))); // 256
typedef u32 u32x4  __attribute__ ((vector_size( 4 * sizeof(u32)))); // 128

typedef u8 u8x64  __attribute__ ((vector_size(64 * sizeof(u8)))); // 512
typedef u8 u8x32  __attribute__ ((vector_size(32 * sizeof(u8)))); // 256
typedef u8 u8x16  __attribute__ ((vector_size(16 * sizeof(u8)))); // 128

// __attribute__((target("popcnt", "avx2")))
//void *aligned_alloc(size_t alignment, size_t size);

#define X_LEN 8

typedef struct ctx_s {
    u64x8 A;
    u64x8 X [X_LEN];
    union {
        u64 tmp64;
        u8  tmp8[8];
    }; uint tsize; // TEMP SIZE
} ctx_s;

static const ctx_s skel = {
    { // A
        0b1111000000100001011100000000110010110000000100101101110111101101ULL,
        0b1101111001010101011010100011000101001110011101000101110000110101ULL,
        0b1001011111000010000000000110100111110111110011101100010110000110ULL,
        0b1011100000010111011100110100110100010110110110000101111111110010ULL,
        0b1101001010110010111110010101111111101011000010110110101110110010ULL,
        0b0000000110111001100011100011100110110110010011001110011000001010ULL,
        0b0001010111111000100111111000100111001011010000011000000111100101ULL,
        0b0010001110110011101110010101010000101001110100100111001110010010ULL,
    }, { { // X
        0b1010100110100010111000110011111110110110000100111100011101011101ULL,
        0b1000011111001101001111010111101100100110100000100101101101100110ULL,
        0b0101010011001110100101010111001101010010010010111100111110001101ULL,
        0b0011011100110101101001110100010010001101001000110101100101001011ULL,
        0b0100110111110110010110101001011100101001010000011000101000000001ULL,
        0b0010000001101101010010111110100110110100100110100010100101111101ULL,
        0b0101111111000011011010001101110000100000010111001101100101000100ULL,
        0b1000001100100001101101111010011011011110000001001000101111000111ULL,
    },{
        0b1111010001001011110111100001001111001110100100111100110110000000ULL,
        0b1000011110100111100010010111000000011111111000010101001010010101ULL,
        0b0001101011011111000100010000001110011001010110111011001010111010ULL,
        0b1010000110101100011101000110100111010001111101111100001011100110ULL,
        0b1011110111111110100100010110010101001100110100001010111101100000ULL,
        0b1101000011000100000111101001111100001101100100010100001100111111ULL,
        0b0101111110000001110001101100100110001100001001011101010001011000ULL,
        0b0100101011010001100100101010100011110011000101011101101110101100ULL,
    },{
        0b0101000100101010010010100000011010101011000101111101111101001101ULL,
        0b0111010101001111000111111100110000101000000000010100101101011001ULL,
        0b1111011101010100010101101101101111101101110110110001000001001100ULL,
        0b1001100101111100010111110000101010111111011000111011000111010111ULL,
        0b0000010100010000011000010001000000000001111000011010110011010111ULL,
        0b1100001001110011100101011101111100000001000010010111110011110110ULL,
        0b1111000000111101110010111101111011011101110111010110100110101000ULL,
        0b0101010000101000100101100111110100011000001001101000011101100100ULL,
    },{
        0b1110111000101100101010000100101011110010100010101100001110010010ULL,
        0b1111000111011101000111000110110000010011000110010010000101011101ULL,
        0b0001110000010011101110111100101110010001101001011110000101101010ULL,
        0b1000000101011011010000011011100101110011101010001000010001110101ULL,
        0b1000001010111110010010110011011110101010010010011101010101000100ULL,
        0b1100011111001001011101101001100111101010011010001010010110101001ULL,
        0b0011100011111000010011111000111110100000001111101110001011110110ULL,
        0b0001111101001110100000000111111010111101001100100101011110011001ULL,
    },{
        0b1001111111010111101100101101110010110110101001010110010111101001ULL,
        0b0001000011011010011100000010101100001101111100111101010001001111ULL,
        0b0101010111111010001010111010000100011000100000001011100110111110ULL,
        0b1011101111001010000101110001100110001000001110101110100101100001ULL,
        0b1011000101100110111111001000100100101101011001100111010001110100ULL,
        0b1110110001110101110111111100111101101010010111001010110000010000ULL,
        0b0111111100000100100010011110101010000001100010000010000101100100ULL,
        0b0110111000001110011011101001101010000000000100001110011101111100ULL,
    },{
        0b1010010010100011011110110001100101111000111000001001101110100101ULL,
        0b1111101001011111000110110010101100001101010011100010001110111111ULL,
        0b0111110100111111111011100000111001101001111100001010010110010001ULL,
        0b0101011000001001111011000011001110100100011110111110100111000000ULL,
        0b1010100111010101100000110110010100000101010110100001000001010010ULL,
        0b0001101001000011100000111111110101100000110100010011000011001100ULL,
        0b0101110111000110010011110000011111110001100010110010011011110100ULL,
        0b1011110111010110000001100101111000111010001111011000100010100001ULL,
    },{
        0b0001111101101010110011000001110000110111010111000101010001111000ULL,
        0b1101110001001000110110001010111111101001111000100000110001101001ULL,
        0b0100001111011101010100110011111000100010111101111100000100111000ULL,
        0b0110111000000010000001100010011000010111010110110011111010100010ULL,
        0b1100011001000101001100010111011101000110110001010110100010011100ULL,
        0b1000011010000001101110010001101011001100111010111100100011010000ULL,
        0b0110010100111001110111111000010100001011010110010100011001110011ULL,
        0b1001111101100100111101111110001110110001110101001110101101110001ULL,
    },{
        0b1111010101001001100101001100110011011000110010001101111011101111ULL,
        0b1001011100101110011001011111110001010010111111001000011010001011ULL,
        0b0010001111100011101011101100010011000110001001001000000000110101ULL,
        0b1001011000011011010011101011101010110001001010011000011111000010ULL,
        0b0000100101100110110101011011001101110001100100000111100011011101ULL,
        0b1101011001101001010001111010110001001110000101100000100111010110ULL,
        0b0011101111011100000101101100100010000001110010111010100011101111ULL,
        0b1111110100100001001101100010101110010100100000100101110011000111ULL,
    }}, { 0 }, 0
};

#define ASSERT(c) ({})

// NOTE: THE HASH IS SAVED BIG ENDIAN
// TODO: restrict ctx vs ctx->temp?
static void __attribute__((optimize("-O3", "-ffast-math", "-fstrict-aliasing"))) _xhash_iter (ctx_s* const restrict ctx, const u64* restrict data, uint q) {
#define A (ctx->A)
#define X (ctx->X)

    ASSERT(data != NULL);
    ASSERT(0 <= q && q <= 2*1024*1024*1024);

    while (q) {
           q--;

        const u64 w = BE64(*data++);

        // ACCUMULATE
        // TODO: MELHOR SE FOREM X64 PARA NAO PERDER OS OVERFLOWS
        // E AI NAO PRECISARA DESSE CAST AQUI, SÓ UM ALI EMBAIXO
        X[7] += X[6] += X[5] += X[4] += X[3] += X[2] += X[1] += X[0] += A +=
            ( (u64x8) {
                0b0001001100010011000100110001001100010011000100110001001100010011ULL,
                0b0010011000100110001001100010011000100110001001100010011000100110ULL,
                0b0100110001001100010011000100110001001100010011000100110001001100ULL,
                0b1001100010011000100110001001100010011000100110001001100010011000ULL,
                0b0011000100110001001100010011000100110001001100010011000100110001ULL,
                0b0110001001100010011000100110001001100010011000100110001001100010ULL,
                0b1100010011000100110001001100010011000100110001001100010011000100ULL,
                0b1000100110001001100010011000100110001001100010011000100110001000ULL,
            } ) & w
        ;

        // E NEM ESSE CAST AQUI
        A += (u64x8) __builtin_shuffle( // TODO: ESSE BUILTIN_SHUFFLE RETORNA MESMO ESTE TIPO?
            // ESCOLHE UM VETOR
                (u8x64) X [popcount64(w) % X_LEN],
            // ESCOLHE AS PALAVRAS DESTE VETOR
               ((u8x64) A) & 0b111111U
        );
    }

#undef A
#undef B
}

void __attribute__((optimize("-O3", "-ffast-math", "-fstrict-aliasing"))) xhash_iter (ctx_s* const restrict ctx, const u8* restrict data, uint size) {

    // NOTE: É SAFE PASSAR DATA NULL COM SIZE 0
    ASSERT(data != NULL || size == 0);

    ASSERT(ctx->tsize <= sizeof(u64));

    // SE TEM, É MANDATÓRIO QUE USE ELE
    if (ctx->tsize) {

        ASSERT(1 <= ctx->tsize && ctx->tsize <= sizeof(u64));

        // QUANTO FALTA PARA COMPLETAR
        uint need = sizeof(u64) - ctx->tsize;

        // MAS SÓ PODE PEGAR O QUE TEM
        if (need > size)
            need = size;

        memcpy(ctx->tmp8 + ctx->tsize, data, need);

        // TIROU DO BUFFER...
        data += need;
        size -= need;

        // ...E COLOCOU NO TEMP
        if ((ctx->tsize += need) != sizeof(u64)) {
            // MAS AINDA NAO TEM UM TEMP COMPLETO
            ASSERT(size == 0);
            return;
        }

        // ENTAO ESTA CONSUMINDO ELE
        ctx->tsize = 0;

        _xhash_iter(ctx, &ctx->tmp64, 1);
    }

    _xhash_iter(ctx, (u64*)data, size / sizeof(u64));

    // VAI SOBRAR ISSO
    const uint sobra = size % sizeof(u64);

    //
    if (sobra)
        memcpy(ctx->tmp8, data + size - sobra, (ctx->tsize = sobra));
}

void __attribute__((optimize("-O3", "-ffast-math", "-fstrict-aliasing"))) xhash_done (ctx_s* const restrict ctx, const u8* restrict data, uint size, u8* const restrict hash) {

    ASSERT(data != NULL || size == 0);

    ASSERT(ctx->tsize <= sizeof(u64));

    if (size) {

        // SE TEM, É MANDATÓRIO QUE USE ELE
        if (ctx->tsize) {

            ASSERT(1 <= ctx->tsize && ctx->tsize <= sizeof(u64));

            // QUANTO FALTA PARA COMPLETAR
            uint need = sizeof(u64) - ctx->tsize;

            // MAS SÓ PODE PEGAR O QUE TEM
            if (need > size)
                need = size;

            memcpy(ctx->tmp8 + ctx->tsize, data, need);

            // TIROU DO BUFFER...
            data += need;
            size -= need;

            // ...E COLOCOU NO CTX
            if ((need = sizeof(u64) - (ctx->tsize + need)))
                // LIMPA ESTA SOBRINHA
                memset(ctx->tmp8 + ctx->tsize, 0, need);

            // ENTAO ESTA CONSUMINDO ELE
            // VAMOS FAZER ISSO MESMO E PERMITIRAR CONTINUAR USANDO O CONTEXTO =]
            ctx->tsize = 0;

            _xhash_iter(ctx, &ctx->tmp64, 1);
        }

        xhash_iter(ctx, data, size);
    }

    // SAVE
    // WARNING: ENDIANESS
    memcpy(hash, &ctx->A, sizeof(ctx->A));
}

static uintptr_t hash_new (void) {

    ctx_s* const ctx = aligned_alloc(sizeof(ctx->A), sizeof(ctx_s));

    if (ctx) {

        memcpy(ctx, &skel, sizeof(ctx_s));

        ASSERT(ctx->tsize == 0);
    }

    return (uintptr_t)ctx;
}

// FOR SPEED
// WE CAN ALWAYS DO A EVEN DEEPER CHECK BY VERIFYING THE HASH OF THE FILES
void __attribute__((optimize("-O3", "-ffast-math", "-fstrict-aliasing"))) xcsum (const void* restrict data, uint size, void* restrict csum) {

    u8x64 A = {
        0x65, 0xAD, 0xA6, 0x3A, 0xD5, 0x6F, 0xC9, 0xB5,
        0x57, 0xD9, 0xAE, 0x14, 0x4D, 0x88, 0x70, 0xED,
        0xEA, 0x65, 0x22, 0xBE, 0xC7, 0x81, 0xFB, 0xD2,
        0xBB, 0x29, 0xE0, 0x3E, 0x64, 0xC7, 0x44, 0xF7,
        0x42, 0x11, 0x5F, 0xAE, 0x08, 0xE4, 0x8A, 0x14,
        0xAF, 0x1C, 0xC4, 0x46, 0xBD, 0x2F, 0xD0, 0x2F,
        0x2A, 0xDB, 0xE1, 0x30, 0xBB, 0xC1, 0xAA, 0x21,
        0x64, 0x4C, 0xCE, 0x63, 0x12, 0x27, 0x1B, 0x4D
    };

    while (size) {

        u64 w;

        if (size >= sizeof(u64)) {
            size -= sizeof(u64);
            w = BE64(*(u64*)data);
            data += sizeof(u64);
        } else {
            size -= sizeof(u8);
            w = BE8(*(u8*)data);
            data += sizeof(u8);
        }

        // ACCUMULATE
        A += (u8x64)(((u64x8){
            0b0000000100000001000000010000000100000001000000010000000100000001ULL,
            0b0000001000000010000000100000001000000010000000100000001000000010ULL,
            0b0000010000000100000001000000010000000100000001000000010000000100ULL,
            0b0000100000001000000010000000100000001000000010000000100000001000ULL,
            0b0001000000010000000100000001000000010000000100000001000000010000ULL,
            0b0010000000100000001000000010000000100000001000000010000000100000ULL,
            0b0100000001000000010000000100000001000000010000000100000001000000ULL,
            0b1000000010000000100000001000000010000000100000001000000010000000ULL,
        }) & w);

        // O FATO DE SER PALAVRINHAS DE 8-BITS TAMBEM SIGNIFICA QUE VAI TER MAIS BITS QUE NÃO DÃO OVERFLOW =]
        A += __builtin_shuffle(A, (A >> popcount64(w)) & 0b111111U);
    }

    // SAVE
    memcpy(csum, &A, sizeof(A));
}
